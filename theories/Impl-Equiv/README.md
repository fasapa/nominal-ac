**Implementations (in OCaml) of the nominal A, C and AC-checking algorithm**


**Compiled with OCaml Version 4.02.3:**


**File** | Short description
------------ | -------------
**[Experiments/](https://github.com/wtonribeiro/nominal-ac/tree/master/Impl-Equiv/Experiments)** | Experiments comparing the Adjusted_Generated_Equiv.ml and the Improved_Equiv.ml implementations
**Original_Generated_Equiv.ml**  | Implementation of a naive version of the nominal A, C and AC equality checking algorithm (the content of this file was automatically generated by Coq)
**Adjusted_Generated_Equiv.ml**  | Previous algorithm replacing naturals by the OCaml integers
**Basics.ml** | Basic data structures and definitions used in Improved_Equiv.ml and Graph_Equiv.ml
**Improved_Equiv.ml** | Implementation of the nominal A, C and AC equality checking algorithm using flattening of A and AC terms and with a simplified version of perfect matching 
**Perfect_Matching.ml** | Implementation of a perfect matching in bitartite graph decision algorithm. This file would be used for nominal matching and unification (this file uses the ocamlgraph library)
**Graph_Equiv.ml** | Implementation of the nominal A, C and AC equality checking algorithm using Perfect_Matching.ml. This file would be adapted for matching and unification
**build.sh**  | Script used to compile the files



**Instructions for compiling and execution:**

1) Install OCaml version >= 4.0 (https://ocaml.org/docs/install.html)


2) Install OPAM (https://opam.ocaml.org/)


3) Install ocamlgraph library (http://ocamlgraph.lri.fr/):

   $ opam update
   
   $ opam install ocamlgraph
   
   $ eval \`opam config env\`
  

4) Being inside folder Impl/ , give permition of execution of build.sh:

   $ sudo chmod +x build.sh


5) Execute: 
   
   $ ./build.sh


6) Install Utop (https://ocaml.org/docs/install.html):

   $ opam update
   
   $ opam install utop
   
   $ eval \`opam config env\`

7) Execute Utop: 
   
   $ utop

8) At the Utop prompt, execute:

   utop # #load "Basics.cmo";;
   
   utop # open Basics;;
   
   utop # #load "Adjusted_Generated_Equiv.cmo";;
   
   utop # open Adjusted_Generated_Equiv;;

   utop # #load "Improved_Equiv.cmo";;
   
   utop # open Improved_Equiv;;


9) At the Utop prompt is possible to test some inputs 
   for each equality checking implementation. Follows some examples:


   a) For the Adjusted_Generated_Equiv implementation:

   utop # equiv_rec Nil Ut Ut;;
   - : Adjusted_Generated_Equiv.bool = True

   utop # equiv_rec Nil (At 0) (At 0);;
   - : Adjusted_Generated_Equiv.bool = True

   utop # equiv_rec Nil (Ab (0, At 0)) (Ab (1, At 1));;
   - : Adjusted_Generated_Equiv.bool = True

   utop # equiv_rec Nil (Ab (0, At 0)) (Ab (1, At 0));;
   - : Adjusted_Generated_Equiv.bool = False
   
   utop # equiv_rec Nil (Fc (0, 1, Pr (At 0, Pr (At 1, At 2)))) (Fc (0, 1, Pr (Pr (At 0, At 1), At 2)));;
   - : Adjusted_Generated_Equiv.bool = True
   
   utop # equiv_rec Nil (Fc (1, 1, Pr (At 0, Pr (At 1, At 2)))) (Fc (1, 1, Pr (Pr (At 2, At 0), At 1)));;
   - : Adjusted_Generated_Equiv.bool = True
   
   b) For the Improved_Equiv implementation:

   utop # impr_equiv [] F_Ut F_Ut;;
   - : bool = True

   utop # impr_equiv [] (F_At 0) (F_At 0);;
   - : bool = True

   utop # impr_equiv [] (F_Ab (0, F_At 0)) (F_Ab (1, F_At 1));;
   - : bool = True

   utop # impr_equiv [] (F_Ab (0, F_At 0)) (F_Ab (1, F_At 0));;
   - : bool = False
   
   utop # impr_equiv [] (flat_term (A (1, [F_At 0; A (1, [F_At 1; F_At 2])]))) (flat_term (A (1, [A (1, [F_At 0; F_At 1]); F_At 2])));;
   - : bool = true
   
   utop # impr_equiv [] (flat_term (AC (1, [F_At 0; AC (1, [F_At 1; F_At 2])]))) (flat_term (AC (1, [AC (1, [F_At 2; F_At 0]); F_At 1])));;
   - : bool = true






